<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker for Go Developers: From Development to Production — KDev</title>
    <meta name="description" content="A practical guide to containerizing Go applications with multi-stage builds, optimization techniques, health checks, and CI/CD integration.">
    <meta name="keywords" content="Docker Go, Golang Docker, Docker multi-stage build, Go deployment, Docker production, container optimization, DevOps Go">
    <meta name="author" content="KDev">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Docker for Go Developers: From Development to Production">
    <meta property="og:description" content="A practical guide to containerizing Go applications with multi-stage builds and CI/CD integration.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://kdev.vercel.app/blog/docker-go-deployment">
    <meta property="article:published_time" content="2026-02-02">
    <meta property="article:author" content="KDev">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="Go">
    
    <!-- AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7247328493564455" crossorigin="anonymous"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>

    <!-- Nav -->
    <nav id="nav">
        <a href="../index.html" class="nav-logo">k<span>.</span>dev</a>
        <div class="nav-links">
            <a href="../index.html">Home</a>
            <a href="../projects.html">Projects</a>
            <a href="../blog.html" class="active">Blog</a>
            <a href="../about.html">About</a>
            <a href="../contact.html">Contact</a>
        </div>
        <div class="nav-status">Available for work</div>
        <button class="nav-toggle" aria-label="Toggle navigation">
            <span></span>
            <span></span>
            <span></span>
        </button>
    </nav>

    <!-- Mobile Menu -->
    <div class="mobile-menu">
        <a href="../index.html">Home</a>
        <a href="../projects.html">Projects</a>
        <a href="../blog.html" class="active">Blog</a>
        <a href="../about.html">About</a>
        <a href="../contact.html">Contact</a>
    </div>

    <!-- Article Header -->
    <header class="page-header">
        <div class="page-header-grid"></div>
        <div class="page-header-content">
            <div class="breadcrumb">
                <a href="../index.html">Home</a>
                <span>/</span>
                <a href="../blog.html">Blog</a>
                <span>/</span>
                <span>Docker Go Deployment</span>
            </div>
            <div class="page-tag">Docker • DevOps</div>
            <h1 class="page-title">Docker for Go Developers: From Development to Production</h1>
            <p class="page-desc">A practical guide to containerizing Go applications — multi-stage builds, optimization techniques, health checks, and CI/CD integration.</p>
        </div>
    </header>

    <!-- Article Content -->
    <article class="container-narrow">
        <div class="article-meta">
            <div class="article-meta-item">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                February 2, 2026
            </div>
            <div class="article-meta-item">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                14 min read
            </div>
            <div class="article-meta-item">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                1,200+ views
            </div>
        </div>

        <div class="article-content">
            <p>Docker and Go are a perfect match. Go compiles to a single static binary, which means your Docker images can be incredibly small and efficient. In this guide, I'll walk you through everything you need to know to containerize Go applications for production.</p>

            <h2>Why Docker for Go?</h2>
            
            <ul>
                <li><strong>Consistent environments</strong> — Same image runs everywhere: development, staging, production</li>
                <li><strong>Tiny images</strong> — Go binaries can run on scratch or distroless images (5-20MB)</li>
                <li><strong>Easy deployment</strong> — Ship containers to any orchestration platform</li>
                <li><strong>Isolation</strong> — Process isolation, resource limits, and security</li>
            </ul>

            <h2>Basic Dockerfile</h2>
            
            <p>Let's start with a simple Dockerfile and then optimize it:</p>

            <pre><code># Simple but not optimized
FROM golang:1.22

WORKDIR /app

COPY . .

RUN go build -o main .

EXPOSE 8080

CMD ["./main"]</code></pre>

            <p>This works but produces a ~1GB image because it includes the entire Go toolchain. Let's do better.</p>

            <h2>Multi-Stage Builds</h2>
            
            <p>Multi-stage builds let you use one image for building and another for running. This dramatically reduces image size:</p>

            <pre><code># Optimized multi-stage build
FROM golang:1.22-alpine AS builder

# Install dependencies for CGO if needed
# RUN apk add --no-cache gcc musl-dev

WORKDIR /app

# Download dependencies first (better layer caching)
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build with optimizations
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -ldflags="-w -s" -o /app/server ./cmd/api

# Final stage - minimal image
FROM alpine:3.19

# Add CA certificates for HTTPS and timezone data
RUN apk --no-cache add ca-certificates tzdata

WORKDIR /app

# Copy only the binary
COPY --from=builder /app/server .

# Optional: copy config files or migrations
# COPY --from=builder /app/config ./config

EXPOSE 8080

# Run as non-root user
RUN adduser -D -g '' appuser
USER appuser

CMD ["./server"]</code></pre>

            <h3>Build Flags Explained</h3>
            
            <ul>
                <li><code>CGO_ENABLED=0</code> — Disable CGO for a fully static binary</li>
                <li><code>GOOS=linux GOARCH=amd64</code> — Cross-compile for Linux</li>
                <li><code>-ldflags="-w -s"</code> — Strip debug symbols (smaller binary)</li>
            </ul>

            <h2>Using Scratch or Distroless</h2>
            
            <p>For the smallest possible images, use scratch or distroless:</p>

            <pre><code># Scratch image - absolutely minimal
FROM golang:1.22-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .

RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -ldflags="-w -s" -o /server ./cmd/api

# Final stage - scratch (empty image)
FROM scratch

# Copy CA certificates for HTTPS
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# Copy timezone data if needed
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# Copy the binary
COPY --from=builder /server /server

EXPOSE 8080

ENTRYPOINT ["/server"]</code></pre>

            <p>Or use Google's distroless images which include a minimal runtime:</p>

            <pre><code># Distroless - minimal but includes some essentials
FROM golang:1.22 AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .

RUN CGO_ENABLED=0 go build -ldflags="-w -s" -o /server ./cmd/api

# Distroless static image
FROM gcr.io/distroless/static-debian12

COPY --from=builder /server /server

EXPOSE 8080

USER nonroot:nonroot

ENTRYPOINT ["/server"]</code></pre>

            <h2>Image Size Comparison</h2>
            
            <table style="width: 100%; border-collapse: collapse; margin: 2rem 0;">
                <thead>
                    <tr style="border-bottom: 2px solid var(--border);">
                        <th style="text-align: left; padding: 0.75rem; color: var(--text-dim);">Base Image</th>
                        <th style="text-align: right; padding: 0.75rem; color: var(--text-dim);">Approximate Size</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">golang:1.22</td>
                        <td style="text-align: right; padding: 0.75rem; color: var(--accent);">~1.1 GB</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">golang:1.22-alpine</td>
                        <td style="text-align: right; padding: 0.75rem; color: var(--accent);">~300 MB</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">alpine:3.19 (final)</td>
                        <td style="text-align: right; padding: 0.75rem; color: var(--accent);">~15-25 MB</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">distroless/static</td>
                        <td style="text-align: right; padding: 0.75rem; color: var(--accent);">~10-20 MB</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.75rem;">scratch</td>
                        <td style="text-align: right; padding: 0.75rem; color: var(--accent);">~5-15 MB</td>
                    </tr>
                </tbody>
            </table>

            <h2>Health Checks</h2>
            
            <p>Production containers should include health checks for orchestration:</p>

            <pre><code># Add health check to Dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1</code></pre>

            <p>And implement the endpoint in your Go app:</p>

            <pre><code>// handlers/health.go
package handlers

import (
    "encoding/json"
    "net/http"
)

type HealthResponse struct {
    Status    string `json:"status"`
    Database  string `json:"database"`
    Cache     string `json:"cache"`
}

func (h *Health) Check(w http.ResponseWriter, r *http.Request) {
    response := HealthResponse{
        Status: "healthy",
    }
    
    // Check database
    if err := h.db.Ping(r.Context()); err != nil {
        response.Status = "unhealthy"
        response.Database = "disconnected"
    } else {
        response.Database = "connected"
    }
    
    // Check cache
    if err := h.cache.Ping(r.Context()); err != nil {
        response.Status = "unhealthy"
        response.Cache = "disconnected"
    } else {
        response.Cache = "connected"
    }
    
    w.Header().Set("Content-Type", "application/json")
    
    if response.Status == "unhealthy" {
        w.WriteHeader(http.StatusServiceUnavailable)
    }
    
    json.NewEncoder(w).Encode(response)
}</code></pre>

            <h2>Docker Compose for Development</h2>
            
            <p>Use Docker Compose for local development with hot reload:</p>

            <pre><code># docker-compose.yml
version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "8080:8080"
    volumes:
      - .:/app
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=postgres
      - DB_PASSWORD=postgres
      - DB_NAME=myapp
      - REDIS_HOST=redis:6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    command: air -c .air.toml

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: myapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db/migrations:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:</code></pre>

            <p>Development Dockerfile with Air for hot reload:</p>

            <pre><code># Dockerfile.dev
FROM golang:1.22-alpine

RUN go install github.com/air-verse/air@latest

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

EXPOSE 8080

CMD ["air", "-c", ".air.toml"]</code></pre>

            <h2>CI/CD Integration</h2>
            
            <p>Here's a GitHub Actions workflow for building and pushing Docker images:</p>

            <pre><code># .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      
      - name: Run tests
        run: go test -race -coverprofile=coverage.out ./...
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.out

  build:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max</code></pre>

            <h2>Production Checklist</h2>
            
            <p>Before deploying to production, ensure:</p>
            
            <ul>
                <li>✅ <strong>Multi-stage build</strong> — Minimal final image</li>
                <li>✅ <strong>Non-root user</strong> — Don't run as root</li>
                <li>✅ <strong>Health checks</strong> — For orchestration</li>
                <li>✅ <strong>Proper signal handling</strong> — Graceful shutdown</li>
                <li>✅ <strong>Resource limits</strong> — Memory and CPU limits set</li>
                <li>✅ <strong>Secrets management</strong> — No secrets in images</li>
                <li>✅ <strong>Logging</strong> — Structured logs to stdout</li>
                <li>✅ <strong>Monitoring</strong> — Metrics endpoint exposed</li>
            </ul>

            <h3>Graceful Shutdown</h3>
            
            <pre><code>func main() {
    // ... setup code ...
    
    srv := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    
    // Start server in goroutine
    go func() {
        log.Printf("Starting server on :8080")
        if err := srv.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatalf("Server error: %v", err)
        }
    }()
    
    // Wait for interrupt signal
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // Give outstanding requests 30s to complete
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }
    
    log.Println("Server exited properly")
}</code></pre>

            <h2>Security Best Practices</h2>
            
            <ul>
                <li><strong>Scan images</strong> — Use Trivy or Snyk to scan for vulnerabilities</li>
                <li><strong>Use specific tags</strong> — Avoid <code>:latest</code>, pin versions</li>
                <li><strong>Read-only filesystem</strong> — Mount as read-only when possible</li>
                <li><strong>Drop capabilities</strong> — Use <code>--cap-drop ALL</code></li>
                <li><strong>Sign images</strong> — Use Docker Content Trust or Cosign</li>
            </ul>

            <pre><code># Run with security options
docker run \
    --read-only \
    --cap-drop ALL \
    --security-opt no-new-privileges \
    --user 1000:1000 \
    -p 8080:8080 \
    myapp:latest</code></pre>

            <h2>Conclusion</h2>
            
            <p>Docker and Go together enable you to build and deploy efficient, secure containerized applications. The key points:</p>
            
            <ul>
                <li>Use multi-stage builds for small images</li>
                <li>Consider scratch or distroless for production</li>
                <li>Implement health checks for orchestration</li>
                <li>Handle signals for graceful shutdown</li>
                <li>Follow security best practices</li>
            </ul>
            
            <p>For more backend content, check out my article on <a href="go-production-api.html">building production-ready APIs with Go</a>.</p>

            <div class="article-tags">
                <a href="#" class="article-tag">Docker</a>
                <a href="#" class="article-tag">Go</a>
                <a href="#" class="article-tag">Golang</a>
                <a href="#" class="article-tag">DevOps</a>
                <a href="#" class="article-tag">CI/CD</a>
                <a href="#" class="article-tag">Containerization</a>
                <a href="#" class="article-tag">Production</a>
            </div>
        </div>
    </article>

    <!-- Related Posts -->
    <section class="related-posts">
        <div class="container-narrow">
            <div class="related-posts-title">Related Articles</div>
            <div class="related-posts-grid">
                <article class="blog-card">
                    <div class="blog-card-category">Go • Backend</div>
                    <h3 class="blog-card-title">
                        <a href="go-production-api.html">Building Production-Ready APIs with Go</a>
                    </h3>
                    <p class="blog-card-excerpt">
                        From project structure to deployment — build robust, scalable APIs.
                    </p>
                    <div class="blog-card-meta">
                        <span>⏱️ 20 min read</span>
                    </div>
                </article>

                <article class="blog-card">
                    <div class="blog-card-category">CI/CD • Automation</div>
                    <h3 class="blog-card-title">
                        <a href="#">Automating Flutter Builds with GitHub Actions</a>
                    </h3>
                    <p class="blog-card-excerpt">
                        Set up automated builds, tests, and deployments for your Flutter apps.
                    </p>
                    <div class="blog-card-meta">
                        <span>⏱️ 11 min read</span>
                    </div>
                </article>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="footer-text">© 2026 <span>k.dev</span> — Crafted with precision</div>
        <div class="footer-links">
            <a href="../index.html" class="footer-link">Home</a>
            <a href="../projects.html" class="footer-link">Projects</a>
            <a href="../blog.html" class="footer-link">Blog</a>
            <a href="../about.html" class="footer-link">About</a>
            <a href="../contact.html" class="footer-link">Contact</a>
        </div>
        <div class="footer-text">Designed & built by <span>KDev</span></div>
    </footer>

    <script>
        // Mobile Menu Toggle
        const navToggle = document.querySelector('.nav-toggle');
        const mobileMenu = document.querySelector('.mobile-menu');

        if (navToggle && mobileMenu) {
            navToggle.addEventListener('click', () => {
                navToggle.classList.toggle('open');
                mobileMenu.classList.toggle('open');
                document.body.style.overflow = mobileMenu.classList.contains('open') ? 'hidden' : '';
            });

            // Close menu when clicking a link
            mobileMenu.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', () => {
                    navToggle.classList.remove('open');
                    mobileMenu.classList.remove('open');
                    document.body.style.overflow = '';
                });
            });
        }

        const nav = document.getElementById('nav');
        window.addEventListener('scroll', () => {
            nav.classList.toggle('scrolled', window.scrollY > 50);
        });
    </script>
</body>
</html>
