<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deploying Go Apps with Docker: From Development to Production ‚Äî KDev</title>
    <meta name="description" content="Complete guide to containerizing Go applications with Docker: multi-stage builds, Docker Compose, health checks, CI/CD pipelines, and production deployment.">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7247328493564455" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>

    <nav id="nav">
        <a href="../index.html" class="nav-logo">k<span>.</span>dev</a>
        <div class="nav-links">
            <a href="../index.html">Home</a>
            <a href="../projects.html">Projects</a>
            <a href="../blog.html" class="active">Blog</a>
            <a href="../about.html">About</a>
            <a href="../contact.html">Contact</a>
        </div>
        <div class="nav-status">Available for work</div>
        <button class="nav-toggle" aria-label="Toggle navigation"><span></span><span></span><span></span></button>
    </nav>

    <div class="mobile-menu">
        <a href="../index.html">Home</a><a href="../projects.html">Projects</a><a href="../blog.html">Blog</a><a href="../about.html">About</a><a href="../contact.html">Contact</a>
    </div>

    <header class="page-header">
        <div class="page-header-grid"></div>
        <div class="page-header-content">
            <div class="breadcrumb"><a href="../index.html">Home</a><span>/</span><a href="../blog.html">Blog</a><span>/</span><span>Docker + Go</span></div>
            <div class="page-tag">Docker ‚Ä¢ DevOps</div>
            <h1 class="page-title">Deploying Go Apps with Docker: From Development to Production</h1>
            <div class="article-meta">
                <span class="article-meta-item">üìÖ January 28, 2026</span>
                <span class="article-meta-item">‚è±Ô∏è 14 min read</span>
                <span class="article-meta-item">‚úçÔ∏è KDev</span>
            </div>
        </div>
    </header>

    <section>
        <div class="container-narrow">
            <article class="article-content" style="padding: 0;">

                <h2>Why Docker + Go?</h2>
                <p>Go and Docker are a perfect combination. Go compiles to a single static binary with zero runtime dependencies, which means your Docker images can be incredibly small ‚Äî often under 15 MB. Compare that to a typical Node.js image at 900+ MB or a Python image at 400+ MB.</p>
                <p>Smaller images mean faster deployments, less bandwidth, smaller attack surface, and lower storage costs. In this guide, I'll walk through every step of containerizing a Go application for production.</p>

                <h2>Multi-Stage Builds</h2>
                <p>The key to small Go images is multi-stage builds. Stage one compiles the binary; stage two copies just the binary into a minimal base image:</p>
                <pre><code># Stage 1: Build the Go binary
FROM golang:1.22-alpine AS builder

WORKDIR /app

# Copy dependency files first (better layer caching)
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build with optimizations
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -ldflags="-s -w -X main.version=1.0.0" \
    -o /app/server ./cmd/server

# Stage 2: Production image
FROM scratch

# Import CA certificates for HTTPS
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# Copy the binary
COPY --from=builder /app/server /server

# Copy config/migrations if needed
COPY --from=builder /app/migrations /migrations

EXPOSE 8080

ENTRYPOINT ["/server"]</code></pre>
                <p><strong>Why <code>scratch</code>?</strong> It's literally an empty image ‚Äî no shell, no package manager, no OS. Your Go binary is the only thing in the container. This is only possible because Go compiles to a static binary.</p>
                <p>The <code>-ldflags="-s -w"</code> strips debug symbols and DWARF information, reducing binary size by about 30%.</p>

                <h2>Alpine vs Scratch vs Distroless</h2>
                <p>You have three main options for your production base image:</p>
                <ul>
                    <li><strong>scratch</strong> ‚Äî Empty, ~0 MB. No shell, no debugging tools. Most secure but hardest to debug.</li>
                    <li><strong>alpine</strong> ‚Äî Minimal Linux, ~5 MB. Has a shell and package manager. Good balance of size and usability.</li>
                    <li><strong>distroless</strong> ‚Äî Google's minimal images, ~2 MB. No shell but includes CA certificates. Good middle ground.</li>
                </ul>
                <p>I recommend <code>scratch</code> for production and <code>alpine</code> for development/debugging:</p>
                <pre><code># Use build argument to switch base image
ARG BASE_IMAGE=scratch
FROM ${BASE_IMAGE}

# Build for dev: docker build --build-arg BASE_IMAGE=alpine -t myapp:dev .
# Build for prod: docker build -t myapp:prod .</code></pre>

                <h2>Docker Compose for Development</h2>
                <p>During development, you need your Go app plus databases, caches, and other services. Docker Compose orchestrates all of them:</p>
                <pre><code># docker-compose.yml
version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "8080:8080"
    volumes:
      - .:/app
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=myapp
      - DB_USER=postgres
      - DB_PASSWORD=secret
      - REDIS_URL=redis://redis:6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    restart: unless-stopped

  postgres:
    image: postgres:16-alpine
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

volumes:
  pgdata:
  redisdata:</code></pre>

                <h2>Development Dockerfile with Hot Reload</h2>
                <p>For development, use <code>air</code> for hot reloading ‚Äî it watches file changes and recompiles automatically:</p>
                <pre><code># Dockerfile.dev
FROM golang:1.22-alpine

RUN go install github.com/air-verse/air@latest

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

# air watches for changes and rebuilds
CMD ["air", "-c", ".air.toml"]</code></pre>
                <pre><code># .air.toml
root = "."
[build]
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ./cmd/server"
  delay = 1000
  exclude_dir = ["tmp", "vendor", "node_modules"]
  include_ext = ["go", "html", "css", "js"]
  kill_delay = "0s"
[log]
  time = false</code></pre>

                <h2>Health Checks</h2>
                <p>Production containers need health checks so the orchestrator knows when to restart or replace them:</p>
                <pre><code>// In your Go app, add a health endpoint
func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) {
    // Check database connectivity
    ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
    defer cancel()

    if err := s.db.PingContext(ctx); err != nil {
        w.WriteHeader(http.StatusServiceUnavailable)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "unhealthy",
            "error":  "database unreachable",
        })
        return
    }

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]string{
        "status": "healthy",
    })
}</code></pre>
                <pre><code># In your Dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD ["/server", "-healthcheck"]

# Or with curl in alpine-based images:
HEALTHCHECK --interval=30s --timeout=3s \
    CMD wget -q --spider http://localhost:8080/health || exit 1</code></pre>

                <h2>Security Best Practices</h2>
                <p>Follow these security practices for production containers:</p>
                <pre><code># Run as non-root user
FROM alpine:3.19 AS final

# Create non-root user
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

COPY --from=builder /app/server /server

# Own the binary
RUN chown appuser:appgroup /server

USER appuser

ENTRYPOINT ["/server"]</code></pre>
                <ul>
                    <li><strong>Non-root user</strong> ‚Äî Never run as root in production. Create a dedicated user.</li>
                    <li><strong>Read-only filesystem</strong> ‚Äî Use <code>docker run --read-only</code> to prevent writes.</li>
                    <li><strong>No secrets in images</strong> ‚Äî Use environment variables or Docker secrets, never bake credentials into images.</li>
                    <li><strong>Pin versions</strong> ‚Äî Use specific image tags like <code>golang:1.22.1-alpine3.19</code>, not <code>golang:latest</code>.</li>
                    <li><strong>Scan images</strong> ‚Äî Use <code>docker scout</code> or <code>trivy</code> to scan for CVEs before deploying.</li>
                </ul>

                <h2>CI/CD Pipeline</h2>
                <p>Here's a GitHub Actions workflow that builds, tests, and deploys your Go container:</p>
                <pre><code># .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Run tests
        run: go test -race -coverprofile=coverage.out ./...

      - name: Build Docker image
        run: |
          docker build \
            --build-arg VERSION=${{ github.sha }} \
            -t myapp:${{ github.sha }} \
            -t myapp:latest .

      - name: Push to registry
        run: |
          echo ${{ secrets.REGISTRY_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker tag myapp:${{ github.sha }} ghcr.io/${{ github.repository }}:${{ github.sha }}
          docker push ghcr.io/${{ github.repository }}:${{ github.sha }}</code></pre>

                <h2>Production Deployment Checklist</h2>
                <ul>
                    <li>‚úÖ Multi-stage build for minimal image size</li>
                    <li>‚úÖ Non-root user in container</li>
                    <li>‚úÖ Health check endpoint and Docker HEALTHCHECK</li>
                    <li>‚úÖ Graceful shutdown handling (see my Go API guide)</li>
                    <li>‚úÖ Structured logging (JSON format for log aggregation)</li>
                    <li>‚úÖ Image scanning for vulnerabilities</li>
                    <li>‚úÖ Resource limits set (memory, CPU)</li>
                    <li>‚úÖ Environment variables for all configuration</li>
                    <li>‚úÖ No secrets baked into the image</li>
                    <li>‚úÖ Automated CI/CD pipeline</li>
                </ul>

                <h2>Conclusion</h2>
                <p>Docker and Go together produce some of the smallest, fastest, and most secure containers you can deploy. Start with multi-stage builds, add health checks, run as non-root, and automate with CI/CD. Your production deployments will be fast, reliable, and easy to manage.</p>

                <div class="article-tags">
                    <a href="../blog.html" class="article-tag">Docker</a>
                    <a href="../blog.html" class="article-tag">Go</a>
                    <a href="../blog.html" class="article-tag">DevOps</a>
                    <a href="../blog.html" class="article-tag">CI/CD</a>
                    <a href="../blog.html" class="article-tag">Deployment</a>
                </div>
            </article>
        </div>
    </section>

    <section style="background: var(--bg-elevated); text-align: center; padding: 6rem 4rem;">
        <div class="section-label" style="justify-content: center;">More Articles</div>
        <h2 class="section-title" style="text-align: center;">Keep Reading</h2>
        <p class="section-desc" style="margin: 0 auto 2rem; text-align: center;">Explore more articles on development.</p>
        <a href="../blog.html" class="btn-primary">‚Üê Back to Blog</a>
    </section>

    <footer>
        <div class="footer-text">¬© 2026 <span>k.dev</span> ‚Äî Crafted with precision</div>
        <div class="footer-links"><a href="../index.html" class="footer-link">Home</a><a href="../projects.html" class="footer-link">Projects</a><a href="../blog.html" class="footer-link">Blog</a><a href="../about.html" class="footer-link">About</a><a href="../contact.html" class="footer-link">Contact</a></div>
        <div class="footer-text">Designed &amp; built by <span>KDev</span></div>
    </footer>

    <script>
        const navToggle=document.querySelector('.nav-toggle'),mobileMenu=document.querySelector('.mobile-menu');if(navToggle&&mobileMenu){navToggle.addEventListener('click',()=>{navToggle.classList.toggle('open');mobileMenu.classList.toggle('open');document.body.style.overflow=mobileMenu.classList.contains('open')?'hidden':''});mobileMenu.querySelectorAll('a').forEach(l=>{l.addEventListener('click',()=>{navToggle.classList.remove('open');mobileMenu.classList.remove('open');document.body.style.overflow=''})})}
        const nav=document.getElementById('nav');window.addEventListener('scroll',()=>{nav.classList.toggle('scrolled',window.scrollY>50)});
    </script>
</body>
</html>
